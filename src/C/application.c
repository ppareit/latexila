/* application.c generated by valac 0.10.2, the Vala compiler
 * generated from application.vala, do not modify */

/*
 * This file is part of LaTeXila.
 *
 * Copyright © 2010 Sébastien Wilmet
 *
 * LaTeXila is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * LaTeXila is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with LaTeXila.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <config.h>
#include <gdk-pixbuf/gdk-pixdata.h>
#include <stdio.h>
#include <gio/gio.h>
#include <gdk/gdk.h>
#include <gtksourceview/gtksourceview.h>
#include <unique/unique.h>


#define TYPE_APPLICATION (application_get_type ())
#define APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLICATION, Application))
#define APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLICATION, ApplicationClass))
#define IS_APPLICATION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLICATION))
#define IS_APPLICATION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLICATION))
#define APPLICATION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLICATION, ApplicationClass))

typedef struct _Application Application;
typedef struct _ApplicationClass ApplicationClass;
typedef struct _ApplicationPrivate ApplicationPrivate;

#define TYPE_MAIN_WINDOW (main_window_get_type ())
#define MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_MAIN_WINDOW, MainWindow))
#define MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_MAIN_WINDOW, MainWindowClass))
#define IS_MAIN_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_MAIN_WINDOW))
#define IS_MAIN_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_MAIN_WINDOW))
#define MAIN_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_MAIN_WINDOW, MainWindowClass))

typedef struct _MainWindow MainWindow;
typedef struct _MainWindowClass MainWindowClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define APPLICATION_TYPE_STOCK_ICON (application_stock_icon_get_type ())
typedef struct _ApplicationStockIcon ApplicationStockIcon;
#define __g_list_free_g_object_unref0(var) ((var == NULL) ? NULL : (var = (_g_list_free_g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_APP_SETTINGS (app_settings_get_type ())
#define APP_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APP_SETTINGS, AppSettings))
#define APP_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APP_SETTINGS, AppSettingsClass))
#define IS_APP_SETTINGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APP_SETTINGS))
#define IS_APP_SETTINGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APP_SETTINGS))
#define APP_SETTINGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APP_SETTINGS, AppSettingsClass))

typedef struct _AppSettings AppSettings;
typedef struct _AppSettingsClass AppSettingsClass;

#define TYPE_DOCUMENT (document_get_type ())
#define DOCUMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DOCUMENT, Document))
#define DOCUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DOCUMENT, DocumentClass))
#define IS_DOCUMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DOCUMENT))
#define IS_DOCUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DOCUMENT))
#define DOCUMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DOCUMENT, DocumentClass))

typedef struct _Document Document;
typedef struct _DocumentClass DocumentClass;

#define TYPE_DOCUMENT_VIEW (document_view_get_type ())
#define DOCUMENT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DOCUMENT_VIEW, DocumentView))
#define DOCUMENT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DOCUMENT_VIEW, DocumentViewClass))
#define IS_DOCUMENT_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DOCUMENT_VIEW))
#define IS_DOCUMENT_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DOCUMENT_VIEW))
#define DOCUMENT_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DOCUMENT_VIEW, DocumentViewClass))

typedef struct _DocumentView DocumentView;
typedef struct _DocumentViewClass DocumentViewClass;
typedef struct _Block19Data Block19Data;

#define TYPE_DOCUMENT_TAB (document_tab_get_type ())
#define DOCUMENT_TAB(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DOCUMENT_TAB, DocumentTab))
#define DOCUMENT_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DOCUMENT_TAB, DocumentTabClass))
#define IS_DOCUMENT_TAB(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DOCUMENT_TAB))
#define IS_DOCUMENT_TAB_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DOCUMENT_TAB))
#define DOCUMENT_TAB_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DOCUMENT_TAB, DocumentTabClass))

typedef struct _DocumentTab DocumentTab;
typedef struct _DocumentTabClass DocumentTabClass;
#define _gtk_icon_source_free0(var) ((var == NULL) ? NULL : (var = (gtk_icon_source_free (var), NULL)))
#define _gtk_icon_set_unref0(var) ((var == NULL) ? NULL : (var = (gtk_icon_set_unref (var), NULL)))

struct _Application {
	GObject parent_instance;
	ApplicationPrivate * priv;
};

struct _ApplicationClass {
	GObjectClass parent_class;
};

struct _ApplicationPrivate {
	GList* _windows;
	MainWindow* _active_window;
};

struct _ApplicationStockIcon {
	char* filename;
	char* stock_id;
};

struct _Block19Data {
	int _ref_count_;
	Application * self;
	MainWindow* window;
};


extern gint application_NEW_WINDOW;
gint application_NEW_WINDOW = 1;
static Application* application_instance;
static Application* application_instance = NULL;
static gpointer application_parent_class = NULL;

GType application_get_type (void) G_GNUC_CONST;
GType main_window_get_type (void) G_GNUC_CONST;
#define APPLICATION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APPLICATION, ApplicationPrivate))
enum  {
	APPLICATION_DUMMY_PROPERTY,
	APPLICATION_WINDOWS,
	APPLICATION_ACTIVE_WINDOW
};
static GType application_stock_icon_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
static ApplicationStockIcon* application_stock_icon_dup (const ApplicationStockIcon* self);
static void application_stock_icon_free (ApplicationStockIcon* self);
static void application_stock_icon_copy (const ApplicationStockIcon* self, ApplicationStockIcon* dest);
static void application_stock_icon_destroy (ApplicationStockIcon* self);
static Application* application_new (void);
static Application* application_construct (GType object_type);
static void application_set_windows (Application* self, GList* value);
static void _g_list_free_g_object_unref (GList* self);
static void application_register_my_stock_icons (Application* self);
GType app_settings_get_type (void) G_GNUC_CONST;
AppSettings* app_settings_get_default (void);
MainWindow* application_create_window (Application* self, GdkScreen* screen);
Application* application_get_default (void);
GType document_get_type (void) G_GNUC_CONST;
GList* application_get_documents (Application* self);
GList* application_get_windows (Application* self);
GList* main_window_get_documents (MainWindow* self);
GType document_view_get_type (void) G_GNUC_CONST;
GList* application_get_views (Application* self);
GList* main_window_get_views (MainWindow* self);
UniqueResponse application_message (Application* self, UniqueApp* sender, gint command, UniqueMessageData* data, guint time);
MainWindow* application_get_active_window (Application* self);
gboolean main_window_is_on_workspace_screen (MainWindow* self, GdkScreen* screen, guint workspace);
static void application_set_active_window (Application* self, MainWindow* value);
void application_create_document (Application* self);
void application_open_documents (Application* self, char** uris);
void main_window_save_state (MainWindow* self, gboolean sync);
MainWindow* main_window_new (void);
MainWindow* main_window_construct (GType object_type);
static void _lambda60_ (Block19Data* _data19_);
void app_settings_save_build_tools (AppSettings* self);
void app_settings_save_most_used_symbols (AppSettings* self);
void app_settings_save_projects (AppSettings* self);
static void __lambda60__gtk_object_destroy (GtkObject* _sender, gpointer self);
static gboolean _lambda61_ (Block19Data* _data19_);
static gboolean __lambda61__gtk_widget_focus_in_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self);
static Block19Data* block19_data_ref (Block19Data* _data19_);
static void block19_data_unref (Block19Data* _data19_);
GType document_tab_get_type (void) G_GNUC_CONST;
DocumentTab* main_window_create_tab (MainWindow* self, gboolean jump_to);
DocumentTab* main_window_open_document (MainWindow* self, GFile* location);
static void application_finalize (GObject* obj);
static void application_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void application_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);

static const ApplicationStockIcon APPLICATION_stock_icons[73] = {{DATA_DIR "/images/icons/compile_dvi.png", "compile_dvi"}, {DATA_DIR "/images/icons/compile_pdf.png", "compile_pdf"}, {DATA_DIR "/images/icons/compile_ps.png", "compile_ps"}, {DATA_DIR "/images/icons/view_dvi.png", "view_dvi"}, {DATA_DIR "/images/icons/view_pdf.png", "view_pdf"}, {DATA_DIR "/images/icons/view_ps.png", "view_ps"}, {DATA_DIR "/images/icons/textbf.png", "bold"}, {DATA_DIR "/images/icons/textit.png", "italic"}, {DATA_DIR "/images/icons/texttt.png", "typewriter"}, {DATA_DIR "/images/icons/textsl.png", "slanted"}, {DATA_DIR "/images/icons/textsc.png", "small_caps"}, {DATA_DIR "/images/icons/textsf.png", "sans_serif"}, {DATA_DIR "/images/icons/roman.png", "roman"}, {DATA_DIR "/images/icons/underline.png", "underline"}, {DATA_DIR "/images/misc-math/set-R.png", "blackboard"}, {DATA_DIR "/images/icons/sectioning-part.png", "sectioning-part"}, {DATA_DIR "/images/icons/sectioning-chapter.png", "sectioning-chapter"}, {DATA_DIR "/images/icons/sectioning-section.png", "sectioning-section"}, {DATA_DIR "/images/icons/sectioning-subsection.png", "sectioning-subsection"}, {DATA_DIR "/images/icons/sectioning-subsubsection.png", "sectioning-subsubsection"}, {DATA_DIR "/images/icons/sectioning-paragraph.png", "sectioning-paragraph"}, {DATA_DIR "/images/icons/character-size.png", "character-size"}, {DATA_DIR "/images/icons/list-itemize.png", "list-itemize"}, {DATA_DIR "/images/icons/list-enumerate.png", "list-enumerate"}, {DATA_DIR "/images/icons/list-description.png", "list-description"}, {DATA_DIR "/images/icons/list-item.png", "list-item"}, {DATA_DIR "/images/icons/references.png", "references"}, {DATA_DIR "/images/icons/math.png", "math"}, {DATA_DIR "/images/icons/math-centered.png", "math-centered"}, {DATA_DIR "/images/icons/math-numbered.png", "math-numbered"}, {DATA_DIR "/images/icons/math-array.png", "math-array"}, {DATA_DIR "/images/icons/math-numbered-array.png", "math-numbered-array"}, {DATA_DIR "/images/icons/math-superscript.png", "math-superscript"}, {DATA_DIR "/images/icons/math-subscript.png", "math-subscript"}, {DATA_DIR "/images/icons/math-frac.png", "math-frac"}, {DATA_DIR "/images/icons/math-square-root.png", "math-square-root"}, {DATA_DIR "/images/icons/math-nth-root.png", "math-nth-root"}, {DATA_DIR "/images/icons/mathcal.png", "mathcal"}, {DATA_DIR "/images/icons/mathfrak.png", "mathfrak"}, {DATA_DIR "/images/icons/delimiters-left.png", "delimiters-left"}, {DATA_DIR "/images/icons/delimiters-right.png", "delimiters-right"}, {DATA_DIR "/images/icons/badbox.png", "badbox"}, {DATA_DIR "/images/icons/logviewer.png", "view_log"}, {DATA_DIR "/images/greek/01.png", "symbol_alpha"}, {DATA_DIR "/images/icons/accent0.png", "accent0"}, {DATA_DIR "/images/icons/accent1.png", "accent1"}, {DATA_DIR "/images/icons/accent2.png", "accent2"}, {DATA_DIR "/images/icons/accent3.png", "accent3"}, {DATA_DIR "/images/icons/accent4.png", "accent4"}, {DATA_DIR "/images/icons/accent5.png", "accent5"}, {DATA_DIR "/images/icons/accent6.png", "accent6"}, {DATA_DIR "/images/icons/accent7.png", "accent7"}, {DATA_DIR "/images/icons/accent8.png", "accent8"}, {DATA_DIR "/images/icons/accent9.png", "accent9"}, {DATA_DIR "/images/icons/accent10.png", "accent10"}, {DATA_DIR "/images/icons/accent11.png", "accent11"}, {DATA_DIR "/images/icons/accent12.png", "accent12"}, {DATA_DIR "/images/icons/accent13.png", "accent13"}, {DATA_DIR "/images/icons/accent14.png", "accent14"}, {DATA_DIR "/images/icons/accent15.png", "accent15"}, {DATA_DIR "/images/icons/mathaccent0.png", "mathaccent0"}, {DATA_DIR "/images/icons/mathaccent1.png", "mathaccent1"}, {DATA_DIR "/images/icons/mathaccent2.png", "mathaccent2"}, {DATA_DIR "/images/icons/mathaccent3.png", "mathaccent3"}, {DATA_DIR "/images/icons/mathaccent4.png", "mathaccent4"}, {DATA_DIR "/images/icons/mathaccent5.png", "mathaccent5"}, {DATA_DIR "/images/icons/mathaccent6.png", "mathaccent6"}, {DATA_DIR "/images/icons/mathaccent7.png", "mathaccent7"}, {DATA_DIR "/images/icons/mathaccent8.png", "mathaccent8"}, {DATA_DIR "/images/icons/mathaccent9.png", "mathaccent9"}, {DATA_DIR "/images/icons/mathaccent10.png", "mathaccent10"}, {DATA_DIR "/images/icons/completion_choice.png", "completion_choice"}, {DATA_DIR "/images/icons/completion_cmd.png", "completion_cmd"}};


static void _g_list_free_g_object_unref (GList* self) {
	g_list_foreach (self, (GFunc) g_object_unref, NULL);
	g_list_free (self);
}


static Application* application_construct (GType object_type) {
	Application * self = NULL;
	GList* _tmp0_;
	gint filenames_length1;
	gint _filenames_size_;
	char** _tmp2_;
	char** _tmp1_ = NULL;
	char** filenames;
	GList* list;
	AppSettings* _tmp4_;
	MainWindow* _tmp5_;
	GError * _inner_error_ = NULL;
	self = (Application*) g_object_new (object_type, NULL);
	application_set_windows (self, _tmp0_ = NULL);
	__g_list_free_g_object_unref0 (_tmp0_);
	gtk_rc_parse_string ("\n" \
"            style \"my-button-style\"\n" \
"            {\n" \
"                GtkWidget::focus-padding = 0\n" \
"                GtkWidget::focus-line-width = 0\n" \
"                xthickness = 0\n" \
"                ythickness = 0\n" \
"            }\n" \
"            widget \"*.my-close-button\" style \"my-button-style\"\n" \
"        ");
	filenames = (_tmp2_ = (_tmp1_ = g_new0 (char*, 5 + 1), _tmp1_[0] = g_strdup (ICONS_DIR "/16x16/apps/latexila.png"), _tmp1_[1] = g_strdup (ICONS_DIR "/22x22/apps/latexila.png"), _tmp1_[2] = g_strdup (ICONS_DIR "/24x24/apps/latexila.png"), _tmp1_[3] = g_strdup (ICONS_DIR "/32x32/apps/latexila.png"), _tmp1_[4] = g_strdup (ICONS_DIR "/48x48/apps/latexila.png"), _tmp1_), filenames_length1 = 5, _filenames_size_ = filenames_length1, _tmp2_);
	list = NULL;
	{
		char** filename_collection;
		int filename_collection_length1;
		int filename_it;
		filename_collection = filenames;
		filename_collection_length1 = filenames_length1;
		for (filename_it = 0; filename_it < filenames_length1; filename_it = filename_it + 1) {
			char* filename;
			filename = g_strdup (filename_collection[filename_it]);
			{
				{
					GdkPixbuf* _tmp3_;
					_tmp3_ = gdk_pixbuf_new_from_file (filename, &_inner_error_);
					if (_inner_error_ != NULL) {
						goto __catch44_g_error;
					}
					list = g_list_append (list, _tmp3_);
				}
				goto __finally44;
				__catch44_g_error:
				{
					GError * e;
					e = _inner_error_;
					_inner_error_ = NULL;
					{
						fprintf (stderr, "Error with an icon: %s\n", e->message);
						_g_error_free0 (e);
					}
				}
				__finally44:
				if (_inner_error_ != NULL) {
					_g_free0 (filename);
					__g_list_free_g_object_unref0 (list);
					filenames = (_vala_array_free (filenames, filenames_length1, (GDestroyNotify) g_free), NULL);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
				_g_free0 (filename);
			}
		}
	}
	gtk_window_set_default_icon_list (list);
	application_register_my_stock_icons (self);
	_tmp4_ = app_settings_get_default ();
	_g_object_unref0 (_tmp4_);
	_tmp5_ = application_create_window (self, NULL);
	_g_object_unref0 (_tmp5_);
	__g_list_free_g_object_unref0 (list);
	filenames = (_vala_array_free (filenames, filenames_length1, (GDestroyNotify) g_free), NULL);
	return self;
}


static Application* application_new (void) {
	return application_construct (TYPE_APPLICATION);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


Application* application_get_default (void) {
	Application* result = NULL;
	if (application_instance == NULL) {
		Application* _tmp0_;
		application_instance = (_tmp0_ = application_new (), _g_object_unref0 (application_instance), _tmp0_);
	}
	result = _g_object_ref0 (application_instance);
	return result;
}


GList* application_get_documents (Application* self) {
	GList* result = NULL;
	GList* res;
	g_return_val_if_fail (self != NULL, NULL);
	res = NULL;
	{
		GList* w_collection;
		GList* w_it;
		w_collection = self->priv->_windows;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			MainWindow* w;
			w = _g_object_ref0 ((MainWindow*) w_it->data);
			{
				res = g_list_concat (res, main_window_get_documents (w));
				_g_object_unref0 (w);
			}
		}
	}
	result = res;
	return result;
}


GList* application_get_views (Application* self) {
	GList* result = NULL;
	GList* res;
	g_return_val_if_fail (self != NULL, NULL);
	res = NULL;
	{
		GList* w_collection;
		GList* w_it;
		w_collection = self->priv->_windows;
		for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
			MainWindow* w;
			w = _g_object_ref0 ((MainWindow*) w_it->data);
			{
				res = g_list_concat (res, main_window_get_views (w));
				_g_object_unref0 (w);
			}
		}
	}
	result = res;
	return result;
}


UniqueResponse application_message (Application* self, UniqueApp* sender, gint command, UniqueMessageData* data, guint time) {
	UniqueResponse result = 0;
	guint workspace;
	GdkScreen* screen;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (sender != NULL, 0);
	g_return_val_if_fail (data != NULL, 0);
	if (command == application_NEW_WINDOW) {
		MainWindow* _tmp0_;
		_tmp0_ = application_create_window (self, NULL);
		_g_object_unref0 (_tmp0_);
		result = UNIQUE_RESPONSE_OK;
		return result;
	}
	workspace = unique_message_data_get_workspace (data);
	screen = _g_object_ref0 (unique_message_data_get_screen (data));
	if (!main_window_is_on_workspace_screen (self->priv->_active_window, screen, workspace)) {
		gboolean found;
		found = FALSE;
		{
			GList* w_collection;
			GList* w_it;
			w_collection = self->priv->_windows;
			for (w_it = w_collection; w_it != NULL; w_it = w_it->next) {
				MainWindow* w;
				w = _g_object_ref0 ((MainWindow*) w_it->data);
				{
					if (w == self->priv->_active_window) {
						_g_object_unref0 (w);
						continue;
					}
					if (main_window_is_on_workspace_screen (w, screen, workspace)) {
						found = TRUE;
						application_set_active_window (self, w);
						_g_object_unref0 (w);
						break;
					}
					_g_object_unref0 (w);
				}
			}
		}
		if (!found) {
			MainWindow* _tmp1_;
			_tmp1_ = application_create_window (self, screen);
			_g_object_unref0 (_tmp1_);
		}
	}
	if (command == UNIQUE_NEW) {
		application_create_document (self);
	} else {
		if (command == UNIQUE_OPEN) {
			char** _tmp2_;
			gint _tmp2__length1;
			application_open_documents (self, (_tmp2_ = unique_message_data_get_uris (data), _tmp2__length1 = -1, _tmp2_));
			_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL);
		}
	}
	gtk_window_present_with_time ((GtkWindow*) self->priv->_active_window, (guint32) time);
	result = UNIQUE_RESPONSE_OK;
	_g_object_unref0 (screen);
	return result;
}


static void _lambda60_ (Block19Data* _data19_) {
	Application * self;
	self = _data19_->self;
	self->priv->_windows = g_list_remove (self->priv->_windows, _data19_->window);
	if (g_list_length (self->priv->_windows) == 0) {
		AppSettings* app_settings;
		app_settings = app_settings_get_default ();
		app_settings_save_build_tools (app_settings);
		app_settings_save_most_used_symbols (app_settings);
		app_settings_save_projects (app_settings);
		gtk_main_quit ();
		_g_object_unref0 (app_settings);
	} else {
		if (_data19_->window == self->priv->_active_window) {
			application_set_active_window (self, MAIN_WINDOW ((MainWindow*) self->priv->_windows->data));
			g_object_notify ((GObject*) self, "active-window");
		}
	}
}


static void __lambda60__gtk_object_destroy (GtkObject* _sender, gpointer self) {
	_lambda60_ (self);
}


static gboolean _lambda61_ (Block19Data* _data19_) {
	Application * self;
	gboolean result = FALSE;
	self = _data19_->self;
	application_set_active_window (self, _data19_->window);
	g_object_notify ((GObject*) self, "active-window");
	result = FALSE;
	return result;
}


static gboolean __lambda61__gtk_widget_focus_in_event (GtkWidget* _sender, GdkEventFocus* event, gpointer self) {
	gboolean result;
	result = _lambda61_ (self);
	return result;
}


static Block19Data* block19_data_ref (Block19Data* _data19_) {
	g_atomic_int_inc (&_data19_->_ref_count_);
	return _data19_;
}


static void block19_data_unref (Block19Data* _data19_) {
	if (g_atomic_int_dec_and_test (&_data19_->_ref_count_)) {
		_g_object_unref0 (_data19_->self);
		_g_object_unref0 (_data19_->window);
		g_slice_free (Block19Data, _data19_);
	}
}


MainWindow* application_create_window (Application* self, GdkScreen* screen) {
	MainWindow* result = NULL;
	Block19Data* _data19_;
	g_return_val_if_fail (self != NULL, NULL);
	_data19_ = g_slice_new0 (Block19Data);
	_data19_->_ref_count_ = 1;
	_data19_->self = g_object_ref (self);
	if (self->priv->_active_window != NULL) {
		main_window_save_state (self->priv->_active_window, TRUE);
	}
	_data19_->window = g_object_ref_sink (main_window_new ());
	application_set_active_window (self, _data19_->window);
	g_object_notify ((GObject*) self, "active-window");
	if (screen != NULL) {
		gtk_window_set_screen ((GtkWindow*) _data19_->window, screen);
	}
	g_signal_connect_data ((GtkObject*) _data19_->window, "destroy", (GCallback) __lambda60__gtk_object_destroy, block19_data_ref (_data19_), (GClosureNotify) block19_data_unref, 0);
	g_signal_connect_data ((GtkWidget*) _data19_->window, "focus-in-event", (GCallback) __lambda61__gtk_widget_focus_in_event, block19_data_ref (_data19_), (GClosureNotify) block19_data_unref, 0);
	self->priv->_windows = g_list_append (self->priv->_windows, _g_object_ref0 (_data19_->window));
	gtk_widget_show ((GtkWidget*) _data19_->window);
	result = _g_object_ref0 (_data19_->window);
	block19_data_unref (_data19_);
	return result;
}


void application_create_document (Application* self) {
	DocumentTab* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = main_window_create_tab (self->priv->_active_window, TRUE);
	_g_object_unref0 (_tmp0_);
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


void application_open_documents (Application* self, char** uris) {
	g_return_if_fail (self != NULL);
	{
		char** uri_collection;
		int uri_collection_length1;
		int uri_it;
		uri_collection = uris;
		uri_collection_length1 = _vala_array_length (uris);
		for (uri_it = 0; uri_it < _vala_array_length (uris); uri_it = uri_it + 1) {
			char* uri;
			uri = g_strdup (uri_collection[uri_it]);
			{
				GFile* location;
				DocumentTab* _tmp0_;
				if (string_get_length (uri) == 0) {
					_g_free0 (uri);
					continue;
				}
				location = g_file_new_for_uri (uri);
				_tmp0_ = main_window_open_document (self->priv->_active_window, location);
				_g_object_unref0 (_tmp0_);
				_g_object_unref0 (location);
				_g_free0 (uri);
			}
		}
	}
}


static void application_register_my_stock_icons (Application* self) {
	GtkIconFactory* icon_factory;
	g_return_if_fail (self != NULL);
	icon_factory = gtk_icon_factory_new ();
	{
		ApplicationStockIcon* icon_collection;
		int icon_collection_length1;
		int icon_it;
		icon_collection = APPLICATION_stock_icons;
		icon_collection_length1 = G_N_ELEMENTS (APPLICATION_stock_icons);
		for (icon_it = 0; icon_it < G_N_ELEMENTS (APPLICATION_stock_icons); icon_it = icon_it + 1) {
			ApplicationStockIcon _tmp0_ = {0};
			ApplicationStockIcon icon;
			icon = (application_stock_icon_copy (&icon_collection[icon_it], &_tmp0_), _tmp0_);
			{
				GtkIconSet* icon_set;
				GtkIconSource* icon_source;
				icon_set = gtk_icon_set_new ();
				icon_source = gtk_icon_source_new ();
				gtk_icon_source_set_filename (icon_source, icon.filename);
				gtk_icon_set_add_source (icon_set, icon_source);
				gtk_icon_factory_add (icon_factory, icon.stock_id, icon_set);
				_gtk_icon_source_free0 (icon_source);
				_gtk_icon_set_unref0 (icon_set);
				application_stock_icon_destroy (&icon);
			}
		}
	}
	gtk_icon_factory_add_default (icon_factory);
	_g_object_unref0 (icon_factory);
}


GList* application_get_windows (Application* self) {
	GList* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_windows;
	return result;
}


static void application_set_windows (Application* self, GList* value) {
	g_return_if_fail (self != NULL);
	self->priv->_windows = value;
	g_object_notify ((GObject *) self, "windows");
}


MainWindow* application_get_active_window (Application* self) {
	MainWindow* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_active_window;
	return result;
}


static void application_set_active_window (Application* self, MainWindow* value) {
	MainWindow* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_active_window = (_tmp0_ = _g_object_ref0 (value), _g_object_unref0 (self->priv->_active_window), _tmp0_);
	g_object_notify ((GObject *) self, "active-window");
}


static void application_stock_icon_copy (const ApplicationStockIcon* self, ApplicationStockIcon* dest) {
	dest->filename = g_strdup (self->filename);
	dest->stock_id = g_strdup (self->stock_id);
}


static void application_stock_icon_destroy (ApplicationStockIcon* self) {
	_g_free0 (self->filename);
	_g_free0 (self->stock_id);
}


static ApplicationStockIcon* application_stock_icon_dup (const ApplicationStockIcon* self) {
	ApplicationStockIcon* dup;
	dup = g_new0 (ApplicationStockIcon, 1);
	application_stock_icon_copy (self, dup);
	return dup;
}


static void application_stock_icon_free (ApplicationStockIcon* self) {
	application_stock_icon_destroy (self);
	g_free (self);
}


static GType application_stock_icon_get_type (void) {
	static volatile gsize application_stock_icon_type_id__volatile = 0;
	if (g_once_init_enter (&application_stock_icon_type_id__volatile)) {
		GType application_stock_icon_type_id;
		application_stock_icon_type_id = g_boxed_type_register_static ("ApplicationStockIcon", (GBoxedCopyFunc) application_stock_icon_dup, (GBoxedFreeFunc) application_stock_icon_free);
		g_once_init_leave (&application_stock_icon_type_id__volatile, application_stock_icon_type_id);
	}
	return application_stock_icon_type_id__volatile;
}


static void application_class_init (ApplicationClass * klass) {
	application_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ApplicationPrivate));
	G_OBJECT_CLASS (klass)->get_property = application_get_property;
	G_OBJECT_CLASS (klass)->set_property = application_set_property;
	G_OBJECT_CLASS (klass)->finalize = application_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), APPLICATION_WINDOWS, g_param_spec_pointer ("windows", "windows", "windows", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), APPLICATION_ACTIVE_WINDOW, g_param_spec_object ("active-window", "active-window", "active-window", TYPE_MAIN_WINDOW, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void application_instance_init (Application * self) {
	self->priv = APPLICATION_GET_PRIVATE (self);
}


static void application_finalize (GObject* obj) {
	Application * self;
	self = APPLICATION (obj);
	_g_object_unref0 (self->priv->_active_window);
	G_OBJECT_CLASS (application_parent_class)->finalize (obj);
}


GType application_get_type (void) {
	static volatile gsize application_type_id__volatile = 0;
	if (g_once_init_enter (&application_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ApplicationClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) application_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Application), 0, (GInstanceInitFunc) application_instance_init, NULL };
		GType application_type_id;
		application_type_id = g_type_register_static (G_TYPE_OBJECT, "Application", &g_define_type_info, 0);
		g_once_init_leave (&application_type_id__volatile, application_type_id);
	}
	return application_type_id__volatile;
}


static void application_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Application * self;
	self = APPLICATION (object);
	switch (property_id) {
		case APPLICATION_WINDOWS:
		g_value_set_pointer (value, application_get_windows (self));
		break;
		case APPLICATION_ACTIVE_WINDOW:
		g_value_set_object (value, application_get_active_window (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void application_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Application * self;
	self = APPLICATION (object);
	switch (property_id) {
		case APPLICATION_WINDOWS:
		application_set_windows (self, g_value_get_pointer (value));
		break;
		case APPLICATION_ACTIVE_WINDOW:
		application_set_active_window (self, g_value_get_object (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}




